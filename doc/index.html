<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>simple-requests 1.0.0 documentation</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="top" title="simple-requests 1.0.0 documentation" href="#" />
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-44991755-1', 'pythonhosted.org');
      ga('send', 'pageview');
    </script>
  </head>
  <body>
      <div class="content">

<span class="target" id="module-simple_requests"></span><h1>simple-requests</h1><p style='font-size:110%; text-align:center;'><em>Asynchronous requests in Python without thinking about it.</em></p>
<div class="section" id="goal">
<h2>Goal<a class="headerlink" href="#goal" title="Permalink to this headline">¶</a></h2>
<p>The goal of this library is to allow you to get the performance benefit of asynchronous requests, without needing to use any asynchronous coding paradigms.  It is built on <a class="reference external" href="https://github.com/surfly/gevent">gevent</a> and <a class="reference external" href="https://github.com/kennethreitz/requests">requests</a>.</p>
<p>If you like getting your hands dirty, the <a class="reference external" href="http://www.gevent.org/gevent.pool.html#gevent.pool.Pool" title="gevent.pool.Pool"><tt class="xref py py-class docutils literal"><span class="pre">gevent.pool.Pool</span></tt></a> and <a class="reference external" href="http://www.python-requests.org/en/latest/api/#sessionapi" title="requests.Session"><tt class="xref py py-class docutils literal"><span class="pre">requests.Session</span></tt></a> that drives the main object is readily available for you to tinker with as much as you&#8217;d like.</p>
</div>
<div class="section" id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this headline">¶</a></h2>
<p>There is also some added functionality not available out-of-the-box from the base libraries:</p>
<ul class="simple">
<li>Request thresholding</li>
<li>Automatic retry on failure, with three different retry strategies included that focus on different applications (big server scrape, small server scrape, API)</li>
<li>Lazy loading and minimal object caching to keep the memory footprint down</li>
</ul>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">simple_requests</span> <span class="kn">import</span> <span class="n">Requests</span>

<span class="c"># Creates a session and thread pool</span>
<span class="n">requests</span> <span class="o">=</span> <span class="n">Requests</span><span class="p">()</span>

<span class="c"># Sends one simple request; the response is returned synchronously.</span>
<span class="n">login_response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">one</span><span class="p">(</span><span class="s">&#39;http://cat-videos.net/login?user=fanatic&amp;password=c4tl0v3r&#39;</span><span class="p">)</span>

<span class="c"># Cookies are maintained in this instance of Requests, so subsequent requests</span>
<span class="c"># will still be logged-in.</span>
<span class="n">profile_urls</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;http://cat-videos.net/profile/mookie&#39;</span><span class="p">,</span>
    <span class="s">&#39;http://cat-videos.net/profile/kenneth&#39;</span><span class="p">,</span>
    <span class="s">&#39;http://cat-videos.net/profile/itchy&#39;</span> <span class="p">]</span>

<span class="c"># Asynchronously send all the requests for profile pages</span>
<span class="k">for</span> <span class="n">profile_response</span> <span class="ow">in</span> <span class="n">requests</span><span class="o">.</span><span class="n">swarm</span><span class="p">(</span><span class="n">profile_urls</span><span class="p">):</span>

    <span class="c"># Asynchronously send requests for each link found on the profile pages</span>
    <span class="c"># These requests take precedence over those in the outer loop to minimize overall waiting</span>
    <span class="c"># Order doesn&#39;t matter this time either, so turn that off for a performance gain</span>
    <span class="k">for</span> <span class="n">friends_response</span> <span class="ow">in</span> <span class="n">requests</span><span class="o">.</span><span class="n">swarm</span><span class="p">(</span><span class="n">profile_response</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="n">maintainOrder</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>

        <span class="c"># Do something intelligent with the responses, like using</span>
        <span class="c"># regex to parse the HTML (see http://stackoverflow.com/a/1732454)</span>
        <span class="n">friends_response</span><span class="o">.</span><span class="n">html</span>
</pre></div>
</div>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
</div>
<dl class="class">
<dt id="simple_requests.Requests">
<em class="property">class </em><tt class="descclassname">simple_requests.</tt><tt class="descname">Requests</tt><big>(</big><em>concurrent=2</em>, <em>minSecondsBetweenRequests=0.15</em>, <em>retryStrategy=<a class="reference internal" href="#simple_requests.Strict" title="simple_requests.Strict"><tt class="xref py py-class docutils literal"><span class="pre">Strict()</span></tt></a></em>, <em>responsePreprocessor=<a class="reference internal" href="#simple_requests.ResponsePreprocessor" title="simple_requests.ResponsePreprocessor"><tt class="xref py py-class docutils literal"><span class="pre">ResponsePreprocessor()</span></tt></a></em><big>)</big><a class="headerlink" href="#simple_requests.Requests" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a session and a thread pool. The intention is to have one instance
per server that you're hitting at the same time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>concurrent</strong> &#8211; (optional) The maximum number of concurrent requests
allowed for this instance.</li>
<li><strong>minSecondsBetweenRequests</strong> &#8211; (optional) Every request is guaranteed to
be separated by at least this many
seconds.</li>
<li><strong>retryStrategy</strong> &#8211; (optional) An instance of <tt class="xref py py-class docutils literal"><span class="pre">RetryStrategy</span></tt> (or subclass).
Allows you to define if and how a request should
be retried on failure. The default implementation
(<a class="reference internal" href="#simple_requests.Strict" title="simple_requests.Strict"><tt class="xref py py-class docutils literal"><span class="pre">Strict</span></tt></a>) retries failed requests twice, for
server errors only, with at least 2 seconds between
each subsequent request. Two other implementations
are included: <a class="reference internal" href="#simple_requests.Lenient" title="simple_requests.Lenient"><tt class="xref py py-class docutils literal"><span class="pre">Lenient</span></tt></a> (good for really small
servers, perhaps hosted out of somebody&#8217;s home), and
<a class="reference internal" href="#simple_requests.Backoff" title="simple_requests.Backoff"><tt class="xref py py-class docutils literal"><span class="pre">Backoff</span></tt></a> (good for APIs).</li>
<li><strong>responsePreprocessor</strong> &#8211; (optional) An instance of <a class="reference internal" href="#simple_requests.ResponsePreprocessor" title="simple_requests.ResponsePreprocessor"><tt class="xref py py-class docutils literal"><span class="pre">ResponsePreprocessor</span></tt></a>
(or subclass).  Useful if you need to override
the default handling of successful responses
and/or failed responses.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="simple_requests.Requests.session">
<tt class="descname">session</tt><a class="headerlink" href="#simple_requests.Requests.session" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference external" href="http://www.python-requests.org/en/latest/api/#sessionapi" title="requests.Session"><tt class="xref py py-class docutils literal"><span class="pre">requests.Session</span></tt></a> that manages things
like maintaining cookies between requests.</p>
</dd></dl>
<dl class="attribute">
<dt id="simple_requests.Requests.pool">
<tt class="descname">pool</tt><a class="headerlink" href="#simple_requests.Requests.pool" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference external" href="http://www.gevent.org/gevent.pool.html#gevent.pool.Pool" title="gevent.pool.Pool"><tt class="xref py py-class docutils literal"><span class="pre">gevent.pool.Pool</span></tt></a> that manages things like
maintaining the number of concurrent requests.  Changes to this
object should be done before any requests are sent.</p>
</dd></dl>
<dl class="method">
<dt id="simple_requests.Requests.one">
<tt class="descname">one</tt><big>(</big><em>request</em>, <em>responsePreprocessor=None</em><big>)</big><a class="headerlink" href="#simple_requests.Requests.one" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute one request synchronously.</p>
<p>Since this request is synchronous, it takes precedence over any other
<a class="reference internal" href="#simple_requests.Requests.each" title="simple_requests.Requests.each"><tt class="xref py py-meth docutils literal"><span class="pre">each()</span></tt></a> or <a class="reference internal" href="#simple_requests.Requests.swarm" title="simple_requests.Requests.swarm"><tt class="xref py py-meth docutils literal"><span class="pre">swarm()</span></tt></a> calls which may still be processing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>request</strong> &#8211; A <tt class="xref py py-class docutils literal"><span class="pre">str</span></tt>, <a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.Request" title="requests.Request"><tt class="xref py py-class docutils literal"><span class="pre">requests.Request</span></tt></a>, or
<a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.PreparedRequest" title="requests.PreparedRequest"><tt class="xref py py-class docutils literal"><span class="pre">requests.PreparedRequest</span></tt></a>.  <tt class="xref py py-class docutils literal"><span class="pre">str</span></tt>
(or any other <tt class="xref py py-class docutils literal"><span class="pre">basestring</span></tt>) will be executed as
an HTTP <tt class="docutils literal"><span class="pre">GET</span></tt>.</li>
<li><strong>responsePreprocessor</strong> &#8211; (optional) Override the default
preprocessor for this request only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A <a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.Response" title="requests.Response"><tt class="xref py py-class docutils literal"><span class="pre">requests.Response</span></tt></a>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simple_requests.Requests.swarm">
<tt class="descname">swarm</tt><big>(</big><em>iterable</em>, <em>maintainOrder=True</em>, <em>responsePreprocessor=None</em><big>)</big><a class="headerlink" href="#simple_requests.Requests.swarm" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute each request asynchronously.</p>
<p>Subsequent calls to <a class="reference internal" href="#simple_requests.Requests.each" title="simple_requests.Requests.each"><tt class="xref py py-meth docutils literal"><span class="pre">each()</span></tt></a>, <a class="reference internal" href="#simple_requests.Requests.swarm" title="simple_requests.Requests.swarm"><tt class="xref py py-meth docutils literal"><span class="pre">swarm()</span></tt></a> or <a class="reference internal" href="#simple_requests.Requests.one" title="simple_requests.Requests.one"><tt class="xref py py-meth docutils literal"><span class="pre">one()</span></tt></a> on the same
<a class="reference internal" href="#simple_requests.Requests" title="simple_requests.Requests"><tt class="xref py py-class docutils literal"><span class="pre">Requests</span></tt></a> instance will be prioritized <em>over</em> earlier calls.
This is generally aligned with how responses are processed (one
response is inspected, which leads to more requests whose responses
are inspected... etc.)</p>
<p>This method will try hard to finish executing all requests, even if the
iterator has fallen out of scope, or an exception was raised, or even
if the execution of the main module is finished.  Use the <a class="reference internal" href="#simple_requests.Requests.stop" title="simple_requests.Requests.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a>
method to cancel any pending requests and/or kill executing requests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>iterable</strong> &#8211; A generator, list, tuple, dictionary, or any other
iterable object containing any combination of
<tt class="xref py py-class docutils literal"><span class="pre">str</span></tt>, <a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.Request" title="requests.Request"><tt class="xref py py-class docutils literal"><span class="pre">requests.Request</span></tt></a>, or
<a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.PreparedRequest" title="requests.PreparedRequest"><tt class="xref py py-class docutils literal"><span class="pre">requests.PreparedRequest</span></tt></a>.  <tt class="xref py py-class docutils literal"><span class="pre">str</span></tt>
(or any other <tt class="xref py py-class docutils literal"><span class="pre">basestring</span></tt>) will be executed
as an HTTP <tt class="docutils literal"><span class="pre">GET</span></tt>.</li>
<li><strong>maintainOrder</strong> &#8211; (optional) By default, the returned responses are
guaranteed to be in the same order as the
requests.  If this is not important to you, set
this to <tt class="docutils literal"><span class="pre">False</span></tt> for a performance gain.</li>
<li><strong>responsePreprocessor</strong> &#8211; (optional) Override the default
preprocessor for these requests only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A <tt class="xref py py-class docutils literal"><span class="pre">ResponseIterator</span></tt> that may be iterated over to get a
<a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.Response" title="requests.Response"><tt class="xref py py-class docutils literal"><span class="pre">requests.Response</span></tt></a>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simple_requests.Requests.each">
<tt class="descname">each</tt><big>(</big><em>iterable</em>, <em>mapToRequest=(lambda i: i.request)</em>, <em>maintainOrder=True</em>, <em>responsePreprocessor=None</em><big>)</big><a class="headerlink" href="#simple_requests.Requests.each" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute a request for each object.</p>
<p>Subsequent calls to <a class="reference internal" href="#simple_requests.Requests.each" title="simple_requests.Requests.each"><tt class="xref py py-meth docutils literal"><span class="pre">each()</span></tt></a>, <a class="reference internal" href="#simple_requests.Requests.swarm" title="simple_requests.Requests.swarm"><tt class="xref py py-meth docutils literal"><span class="pre">swarm()</span></tt></a> or <a class="reference internal" href="#simple_requests.Requests.one" title="simple_requests.Requests.one"><tt class="xref py py-meth docutils literal"><span class="pre">one()</span></tt></a> on the same
<a class="reference internal" href="#simple_requests.Requests" title="simple_requests.Requests"><tt class="xref py py-class docutils literal"><span class="pre">Requests</span></tt></a> instance will be prioritized <em>over</em> earlier calls.
This is generally aligned with how responses are processed (one
response is inspected, which leads to more requests whose responses
are inspected... etc.)</p>
<p>This method will try hard to finish executing all requests, even if the
iterator has fallen out of scope, or an exception was raised, or even
if the execution of the main module is finished.  Use the <a class="reference internal" href="#simple_requests.Requests.stop" title="simple_requests.Requests.stop"><tt class="xref py py-meth docutils literal"><span class="pre">stop()</span></tt></a>
method to cancel any pending requests and/or kill executing requests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>iterable</strong> &#8211; A generator, list, tuple, dictionary, or any other
iterable.</li>
<li><strong>mapToRequest</strong> &#8211; (optional) By default, the <tt class="xref py py-attr docutils literal"><span class="pre">request</span></tt> attribute (or property) is used.  If such an attribute does not exist (or some other behaviour is desired), this function will be used to get a request for each object in the iterable.  The returned response must be a <tt class="xref py py-class docutils literal"><span class="pre">str</span></tt>, <a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.Request" title="requests.Request"><tt class="xref py py-class docutils literal"><span class="pre">requests.Request</span></tt></a>, or
<a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.PreparedRequest" title="requests.PreparedRequest"><tt class="xref py py-class docutils literal"><span class="pre">requests.PreparedRequest</span></tt></a>.</li>
<li><strong>maintainOrder</strong> &#8211; (optional) By default, the order is <em>not</em> maintained between the iterable and the responses.  Set this to <tt class="docutils literal"><span class="pre">True</span></tt> to guarantee that the order is maintained.</li>
<li><strong>responsePreprocessor</strong> &#8211; (optional) Override the default
preprocessor for these requests only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A <tt class="xref py py-class docutils literal"><span class="pre">ResponseIterator</span></tt> that may be iterated over to get a
(<a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.Response" title="requests.Response"><tt class="xref py py-class docutils literal"><span class="pre">requests.Response</span></tt></a>, object) tuple for each object in the given iterable.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simple_requests.Requests.stop">
<tt class="descname">stop</tt><big>(</big><em>killExecuting=True</em><big>)</big><a class="headerlink" href="#simple_requests.Requests.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the execution of requests early.</p>
<p>The <a class="reference internal" href="#simple_requests.Requests.swarm" title="simple_requests.Requests.swarm"><tt class="xref py py-meth docutils literal"><span class="pre">swarm()</span></tt></a> method will try hard to finish executing all requests,
even if the iterator has fallen out of scope, or an exception was
raised, or even if the execution of the main module is finished.</p>
<p>Use this method to cancel all pending requests.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>killExecuting</strong> &#8211; (optional) In addition to canceling pending
requests, kill any currently-executing requests
so that the response will not be returned. While
this has the benefit of guaranteeing that there
will be no more activity once the method returns,
it means that it is undeterminable whether any
current requests succeeded, failed, or had any
server side-effects.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="simple_requests.Bundle">
<em class="property">class </em><tt class="descclassname">simple_requests.</tt><tt class="descname">Bundle</tt><a class="headerlink" href="#simple_requests.Bundle" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used internally to "bundle up" a request, response, and associated object (if it exists).</p>

<dl class="attribute">
<dt id="simple_requests.Bundle.request">
<tt class="descname">request</tt><a class="headerlink" href="#simple_requests.Bundle.request" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.Request" title="requests.Request"><tt class="xref py py-class docutils literal"><span class="pre">requests.Request</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="simple_requests.Bundle.response">
<tt class="descname">response</tt><a class="headerlink" href="#simple_requests.Bundle.response" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.Response" title="requests.Response"><tt class="xref py py-class docutils literal"><span class="pre">requests.Response</span></tt></a>.  May be <tt class="docutils literal"><span class="pre">None</span></tt> if the request has not yet been sent or the raised an exception while being prepared.</p>
</dd></dl>

<dl class="attribute">
<dt id="simple_requests.Bundle.exception">
<tt class="descname">exception</tt><a class="headerlink" href="#simple_requests.Bundle.exception" title="Permalink to this definition">¶</a></dt>
<dd><p>An instance of <tt class="xref py py-class docutils literal"><span class="pre">Exception</span></tt></a>.  Will be <tt class="docutils literal"><span class="pre">None</span></tt> if the request has not yet been sent or was executed successfully.</p>
</dd></dl>

<dl class="attribute">
<dt id="simple_requests.Bundle.obj">
<tt class="descname">obj</tt><a class="headerlink" href="#simple_requests.Bundle.obj" title="Permalink to this definition">¶</a></dt>
<dd><p>The object associated with the request, if <a class="reference internal" href="#simple_requests.Requests.each" title="simple_requests.Requests.each"><tt class="xref py py-meth docutils literal"><span class="pre">each()</span></tt></a> was used, <tt class="docutils literal"><span class="pre">None</span></tt> otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="simple_requests.Bundle.hasobj">
<tt class="descname">hasobj</tt><a class="headerlink" href="#simple_requests.Bundle.hasobj" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">True</span></tt> if <a class="reference internal" href="#simple_requests.Bundle.obj" title="simple_requests.Bundle.obj"><tt class="xref py py-attr docutils literal"><span class="pre">obj</span></tt></a> is set to an associated object, <tt class="docutils literal"><span class="pre">False</span></tt> otherwise.  Necessary in case the object itself is <tt class="docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="simple_requests.ResponsePreprocessor">
<em class="property">class </em><tt class="descclassname">simple_requests.</tt><tt class="descname">ResponsePreprocessor</tt><a class="headerlink" href="#simple_requests.ResponsePreprocessor" title="Permalink to this definition">¶</a></dt>
<dd><p>Default implementation of how responses are preprocessed.</p>
<p>By default, successful responses are returned and errors are raised.
Whatever is returned by <a class="reference internal" href="#simple_requests.ResponsePreprocessor.success" title="simple_requests.ResponsePreprocessor.success"><tt class="xref py py-meth docutils literal"><span class="pre">success()</span></tt></a> and <a class="reference internal" href="#simple_requests.ResponsePreprocessor.error" title="simple_requests.ResponsePreprocessor.error"><tt class="xref py py-meth docutils literal"><span class="pre">error()</span></tt></a> is what gets
returned by <a class="reference internal" href="#simple_requests.Requests.one" title="simple_requests.Requests.one"><tt class="xref py py-meth docutils literal"><span class="pre">one()</span></tt></a> and the iterator of <a class="reference internal" href="#simple_requests.Requests.swarm" title="simple_requests.Requests.swarm"><tt class="xref py py-meth docutils literal"><span class="pre">swarm()</span></tt></a>.</p>
<p>There are several reasons you may want to override the default
implementation:</p>
<ul class="simple">
<li>Don&#8217;t raise an exception on server errors</li>
<li>Add a side-effect, such as writing all responses to an archive file</li>
<li>Responses in your application must always be pre-processed in a
specific way</li>
<li>More...</li>
</ul>

<dl class="method">
<dt id="simple_requests.ResponsePreprocessor.success">
<tt class="descname">success</tt><big>(</big><em>bundle</em><big>)</big><a class="headerlink" href="#simple_requests.ResponsePreprocessor.success" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a successful request.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bundle</strong> &#8211; A <a class="reference internal" href="#simple_requests.Bundle" title="simple_requests.Bundle"><tt class="xref py py-class docutils literal"><span class="pre">Bundle</span></tt></a>.  The <a class="reference internal" href="#simple_requests.Bundle.response" title="simple_requests.Bundle.response"><tt class="xref py py-attr docutils literal"><span class="pre">response</span></tt></a> attribute will be populated, and <a class="reference internal" href="#simple_requests.Bundle.exception" title="simple_requests.Bundle.exception"><tt class="xref py py-attr docutils literal"><span class="pre">exception</span></tt></a> will be <tt class="docutils literal"><span class="pre">None</span></tt>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="simple_requests.ResponsePreprocessor.error">
<tt class="descname">error</tt><big>(</big><em>bundle</em><big>)</big><a class="headerlink" href="#simple_requests.ResponsePreprocessor.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle a failed request.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bundle</strong> &#8211; A <a class="reference internal" href="#simple_requests.Bundle" title="simple_requests.Bundle"><tt class="xref py py-class docutils literal"><span class="pre">Bundle</span></tt></a>.  The <a class="reference internal" href="#simple_requests.Bundle.exception" title="simple_requests.Bundle.exception"><tt class="xref py py-attr docutils literal"><span class="pre">exception</span></tt></a> attribute will be populated, but <a class="reference internal" href="#simple_requests.Bundle.response" title="simple_requests.Bundle.response"><tt class="xref py py-attr docutils literal"><span class="pre">response</span></tt></a> may be <tt class="docutils literal"><span class="pre">None</span></tt> (depending on the kind of error).</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="simple_requests.Strict">
<em class="property">class </em><tt class="descclassname">simple_requests.</tt><tt class="descname">Strict</tt><a class="headerlink" href="#simple_requests.Strict" title="Permalink to this definition">¶</a></dt>
<dd><p>A good default <tt class="xref py py-class docutils literal"><span class="pre">RetryStrategy</span></tt>.</p>
<p>Retries up to two times, with 2 seconds between each attempt.</p>
<p>Non-server errors are not retried.</p>
</dd></dl>

<dl class="class">
<dt id="simple_requests.Lenient">
<em class="property">class </em><tt class="descclassname">simple_requests.</tt><tt class="descname">Lenient</tt><a class="headerlink" href="#simple_requests.Lenient" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="xref py py-class docutils literal"><span class="pre">RetryStrategy</span></tt> designed for very small servers.</p>
<p>Small servers are expected to go down every now and then, so this
strategy retries requests up to 4 times, with a full minute between each
attempt.</p>
<p>Non-server errors are retried only once after 60 seconds.</p>
</dd></dl>

<dl class="class">
<dt id="simple_requests.Backoff">
<em class="property">class </em><tt class="descclassname">simple_requests.</tt><tt class="descname">Backoff</tt><a class="headerlink" href="#simple_requests.Backoff" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="xref py py-class docutils literal"><span class="pre">RetryStrategy</span></tt> designed for APIs.</p>
<p>Since APIs are <em>expected</em> to work, this implementation retries many times,
with an exponentially-increasing time in between each request (capped at
60 seconds).</p>
<p>Non-server errors are retried only once after 10 seconds.</p>
</dd></dl>

<dl class="class">
<dt id="simple_requests.HTTPError">
<em class="property">class </em><tt class="descclassname">simple_requests.</tt><tt class="descname">HTTPError</tt><big>(</big><em>response</em><big>)</big><a class="headerlink" href="#simple_requests.HTTPError" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulates server errors (status codes in the 400s and 500s).</p>
<dl class="attribute">
<dt id="simple_requests.HTTPError.code">
<tt class="descname">code</tt><a class="headerlink" href="#simple_requests.HTTPError.code" title="Permalink to this definition">¶</a></dt>
<dd><p>Status code for this error.</p>
</dd></dl>

<dl class="attribute">
<dt id="simple_requests.HTTPError.msg">
<tt class="descname">msg</tt><a class="headerlink" href="#simple_requests.HTTPError.msg" title="Permalink to this definition">¶</a></dt>
<dd><p>The reason (associated with the status code).</p>
</dd></dl>

<dl class="attribute">
<dt id="simple_requests.HTTPError.response">
<tt class="descname">response</tt><a class="headerlink" href="#simple_requests.HTTPError.response" title="Permalink to this definition">¶</a></dt>
<dd><p>The instance of <a class="reference external" href="http://www.python-requests.org/en/latest/api/#requests.Response" title="requests.Response"><tt class="xref py py-class docutils literal"><span class="pre">requests.Response</span></tt></a> which triggered the error.</p>
</dd></dl>

</dd></dl>

    <div class="footer">
        &copy; Copyright 2013, Corey Theiss.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b3.
    </div>
  </body>
</html>